/*
Trigger that handles UPDATE and DELETE operations, a row-level trigger.

Parameters:
1) v_pkey_cols: string containing a literal text array of the table-to-log's primary key column name(s). e.g. in 'raw' format this might be
     ARRAY['user_id'], or {'user_id'}, and when converted to a string (i.e. quoting & escaping single quotes) this would be '{"user_id"}'
2) v_ignore_cols: string containing literal text array of any column names to NEVER log. e.g. {'huge_expensive_field_we_dont_need_to_log'}
3) v_blame_col: if this col is set, you should in every INSERT, UPDATE or DELETE operation set to the person in your system who made the operation

NB: We'd rather pass text arrays directly, but triggers only support passing string params, so we pass string literals and cast
to ::text[] inside the trigger.

ignore_cols is a list of columns to completely ignore regardless of the operation type, and is intended for columns
that won't matter during a restore, or columns that can't be converted to JSONB (e.g. BLOBs), or can't be efficiently stored
e.g. very large text fields that you don't care about. Since these are pretty rare, it's likely for this param to be empty.

*/
CREATE OR REPLACE FUNCTION changelog_insert_update_delete_trigger() 
RETURNS TRIGGER LANGUAGE plpgsql AS $$ 
DECLARE 
    v_pkey_cols text[] := TG_ARGV[0]::text[];
    v_ignore_cols text[] := TG_ARGV[1]::text[];
    v_blame_col text := TG_ARGV[2]::text;
    _history_schema text := 'history';
    _history_table_name text := 'history_' || TG_TABLE_NAME;
    _row_id jsonb := '{}' :: jsonb;
    _blame text := 'undefined';
    _before jsonb := '{}' :: jsonb;
    _after jsonb := '{}' :: jsonb;
    _changes jsonb := '{}' :: jsonb;
       
    _item RECORD;
    _pkey_col_name text;   
    _take_ids_from jsonb := '{}' :: jsonb; 
BEGIN
   -- create history schema if not preset
    EXECUTE format( 'CREATE SCHEMA IF NOT EXISTS %I', _history_schema );
    -- create history table for the table running the trigger
    EXECUTE format( 'CREATE TABLE IF NOT EXISTS %I.%I (
        id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY , row_id jsonb NOT NULL , AT TIMESTAMP WITH TIME zone NOT NULL , blame VARCHAR(255) NOT NULL , type text NOT NULL , BEFORE jsonb NOT NULL , after jsonb NOT NULL , changes jsonb NOT NULL )', 
        _history_schema, _history_table_name );
    EXECUTE format( 'CREATE INDEX IF NOT EXISTS %I_idx ON %I.%I(row_id)'
       	, _history_table_name, _history_schema, _history_table_name);    

    -- set _before and _after
    _before := COALESCE(to_jsonb(OLD) - v_ignore_cols, _before); -- NB: this removes any columns we want to ignore
    _after := COALESCE(to_jsonb(NEW) - v_ignore_cols, _after); -- NB: this removes any columns we want to ignore
    
    -- prepare _blame (only for updates and inserts) 
    _blame := COALESCE(to_jsonb(NEW)->>v_blame_col, _blame||': '||v_blame_col||' column value not set'); -- using ->> because it is a jsonb
    IF TG_OP = 'DELETE' THEN
        _blame := 'unable to set blame column in a DELETE DDL';
    END IF;

    -- prepare _changes
    FOR _item IN
        SELECT key, value FROM jsonb_each(_after)
        UNION
        SELECT key, value FROM jsonb_each(_before)
    LOOP
        IF COALESCE(_after->_item.key, NULL) IS DISTINCT FROM COALESCE(_before->_item.key, NULL) THEN
            _changes := jsonb_set(_changes, ARRAY[_item.key], jsonb_build_object('old', COALESCE(_before->_item.key, NULL), 'new', COALESCE(_after->_item.key, NULL)), true);
        END IF;
    END LOOP;        
    
   -- manage row_ids
    _take_ids_from := to_jsonb(OLD);
    IF TG_OP = 'UPDATE' OR TG_OP = 'INSERT' THEN
        _take_ids_from := to_jsonb(NEW);		    
    END IF;        
    FOREACH _pkey_col_name IN ARRAY v_pkey_cols
    loop
        _row_id := jsonb_set(_row_id, ARRAY[_pkey_col_name], _take_ids_from->_pkey_col_name);
    END LOOP;
           
    -- run execution
    EXECUTE format( 'INSERT INTO %I.%I (row_id, at, blame, type, before, after, changes)
        VALUES ($1, CURRENT_TIMESTAMP, $2, $3, $4, $5, $6)'
        , _history_schema, _history_table_name ) 
    USING _row_id, _blame, TG_OP, _before, _after, _changes;
   
    RETURN NULL; -- Ignored
end $$;
